<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="static/styles.css">
  <title>Book Recommendation</title>
</head>
<body>
<div class="container">
  <h1>Book Recommendation System</h1>
  <div class="tabs">
    <button class="tab" data-tab="noXAI">No XAI</button>
    <button class="tab" data-tab="lime">LIME</button>
    <button class="tab" data-tab="anchor">Anchor</button>
  </div>
  <div id="tabContentContainer">
    <!-- Tab content for No XAI, LIME, SHAP, Counterfactual -->
    <div id="noXAI" class="tab-content" style="display:none;">
      <h2>This tab does not have explanations</h2>
      <input type="text" id="bookTitleNoXAI" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorNoXAI" checked>
        <label for="includeSameAuthorNoXAI">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="noXAI">Get Recommendations</button>
      <ul id="recommendationsNoXAI"></ul>
    </div>
    <div id="lime" class="tab-content" style="display:none;">
      <h2>LIME Explanation</h2>
      <p> Please allow a few moments for the explanations to load.</p>
      <input type="text" id="bookTitleLime" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorLime" checked>
        <label for="includeSameAuthorLime">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="lime">Get Recommendations</button>
      <ul id="recommendationsLime"></ul>
      <div id="limeExplanation">
        <h2>LIME Explanations for Recommended Books:<span id="explainedTitleLime"></span></h2>
        <p id="limeExplanationGeneral">These recommendations are formed using the description of your original book, which was used to search for similar books within Google Books Respository.
          The LIME explanation displays the relevant words within the description, starting with the highest weighted word.
          These words from the description are available as an explanation for why this book as a good recommendation.</p>
        <ul id="limeExplanationList"></ul>
      </div>
    </div>
    <div id="anchor" class="tab-content" style="display:none;">
      <h2>Anchor Explanation</h2>
      <p> Please allow a few moments for the explanations to load. It can take a while. This is normal. An error message will appear if the explanations fail to load.</p>
      <input type="text" id="bookTitleAnchor" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorAnchor" checked>
        <label for="includeSameAuthorAnchor">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="anchor">Get Recommendations</button>
      <ul id="recommendationsAnchor"></ul>
      <div id="anchorExplanation">
        <h2>Anchor Explanations for Recommended Books:</h2>
        <p id="anchorExplanationGeneral"> These recommendations are formed using the description of your original book, which was used to search for similar books within the Google Books Repository.
          The Anchor explanation identifies the most critical features (or "anchors") from the book description that strongly support why the recommendation was made. These anchors represent words or phrases that are most influential in determining the similarity and relevance of this book as a good recommendation.
          The precision is a measure of how often the explanation's key features correctly predict the recommendation, expressed as a percentage of accuracy. </p>
        <ul id="anchorExplanationList"></ul>
      </div>
    </div>

  </div>
</div>
<script>
  window.addEventListener("DOMContentLoaded", initTabs);
  document.querySelectorAll('.get-recommendations-button').forEach(button => {
    button.addEventListener('click', async () => {
      const tab = button.dataset.tab;
      await getRecommendations(tab);
    });
  });
  function initTabs() {
    const tabButtons = document.querySelectorAll(".tab");
    showTabContent("noXAI");
    document.querySelector('.tab[data-tab="noXAI"]').classList.add("active");
    tabButtons.forEach(button => button.addEventListener("click", () => handleTabClick(button.dataset.tab)));
  }

  function handleTabClick(tabId) {
    document.querySelectorAll(".tab").forEach(button => button.classList.remove("active"));
    document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add("active");
    showTabContent(tabId);
  }

  function showTabContent(tabId) {
    document.querySelectorAll(".tab-content").forEach(content => {
      content.style.display = content.id === tabId ? "block" : "none";
    });
  }

  // Function to filter non-zero elements in vectorized_descriptions
  function filterNonZeroFeatures(descriptionVector, featureNames) {
    return descriptionVector.reduce((filteredData, weight, index) => {
      if (weight !== 0) {
        filteredData.vectorized_descriptions.push(weight);
        filteredData.feature_names.push(featureNames[index]);
      }
      return filteredData;
    }, { vectorized_descriptions: [], feature_names: [] });
  }

  const stopwords = new Set([
                              "i", "me", "my", "myself", "we", "our", "ours", "ourselves", "you", "your", "yours", "yourself", "yourselves",
                              "he", "him", "his", "himself", "she", "her", "hers", "herself", "it", "its", "itself", "they", "them", "their",
                              "theirs", "themselves", "what", "which", "who", "whom", "this", "that", "these", "those", "am", "is", "are",
                              "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "a", "an",
                              "the", "and", "but", "if", "or", "because", "as", "until", "while", "of", "at", "by", "for", "with", "about",
                              "against", "between", "into", "through", "during", "before", "after", "above", "below", "to", "from", "up",
                              "down", "in", "out", "on", "off", "over", "under", "again", "further", "then", "once", "here", "there",
                              "when", "where", "why", "how", "all", "any", "both", "each", "few", "more", "most", "other", "some",
                              "such", "no", "nor", "not", "only", "own", "same", "so", "than", "too", "very", "s", "t", "can", "will",
                              "just", "don", "should", "now", "12th", "1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th", "11th"
                            ]);


  function cleanDescription(description) {
    // Regular expression to remove punctuation and numbers
    const words = description
        .replace(/[0-9.,/#!$%^&*;:{}=_`~()]/g, "")
        .toLowerCase()
        .split(" ");

    // Filter out stopwords and ensure words are alphanumeric only
    const cleanedWords = words.filter(word =>
                                          word && !stopwords.has(word) && /^[a-zA-Z]+$/.test(word)
    );

    // Join the cleaned words into a cleaned description string
    return cleanedWords.join(" ");
  }


  async function getRecommendations(tab) {
    console.log(`Fetching recommendations for tab: ${tab}`);
    const recommendations = [];
    const inputId = `bookTitle${capitalize(tab)}`;
    const bookTitle = document.getElementById(inputId).value.toLowerCase();
    const recommendationsId = `recommendations${capitalize(tab)}`;
    const recommendationsList = document.getElementById(recommendationsId);
    recommendationsList.innerHTML = '';

    const includeSameAuthor = document.getElementById(`includeSameAuthor${capitalize(tab)}`).checked;
    const googleApiKey = 'AIzaSyDQTQy3LT7BOO_LLClbWuEvqiPbUbWWKBs'; // Replace with your actual API key
    const googleApiUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(bookTitle)}&maxResults=40&key=${googleApiKey}`;

    let books;
    try {
      const apiResponse = await fetch(googleApiUrl);
      const apiData = await apiResponse.json();
      books = apiData.items || [];
      console.log("Books fetched from Google API:", books);
    } catch (error) {
      console.error("Error fetching books from Google API", error);
      return;
    }

    const processedBooks = books.map(book => ({
      title: book.volumeInfo.title || "Unknown Title",
      authors: book.volumeInfo.authors || [],
      description: cleanDescription(book.volumeInfo.description || "No description available"),
      link: book.volumeInfo.infoLink || "#"
    })).filter(book => book.description && book.description.length > 50);


    const descriptions = processedBooks.map(book => book.description);
    const selectedBook = processedBooks.find(book => book.title.toLowerCase() === bookTitle.toLowerCase());

    if (!selectedBook) {
      console.error("Selected book not found in API response");
      return;
    }

    let tfidfData;
    try {
      const response = await fetch("/vectorize-descriptions", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({descriptions})
      });
      tfidfData = await response.json();
      console.log("TF-IDF vectorization data received from backend:", tfidfData);
    } catch (error) {
      console.error("Error during TF-IDF vectorization:", error);
      return;
    }

    const {tfidf_matrix, feature_names, vectorized_descriptions} = tfidfData;
    console.log("Processed Books:", processedBooks);
    console.log("TF-IDF Matrix:", tfidf_matrix);
    console.log("Vectorized Descriptions:", vectorized_descriptions);


    // Generate final recommendations
    const finalRecommendations = filterRecommendations(processedBooks, tfidf_matrix, vectorized_descriptions, includeSameAuthor);
    console.log("Final filtered recommendations:", finalRecommendations);

    if (finalRecommendations.length === 0) {
      recommendationsList.innerHTML = "<li>No valid recommendations found.</li>";
      return;
    }

    finalRecommendations.forEach((bookInfo, index) => {
      const bookVector = tfidf_matrix[index];
      const nonZeroFeatures = filterNonZeroFeatures(bookVector, feature_names);

      recommendations.push({
                             title: bookInfo.title,
                             vectorized_descriptions: nonZeroFeatures.vectorized_descriptions,
                             feature_names: nonZeroFeatures.feature_names
                           });
      // Add a console log to check the values being pushed
      console.log("Recommendation added:", {
        title: bookInfo.title,
        vectorized_descriptions: nonZeroFeatures.vectorized_descriptions,
        feature_names: nonZeroFeatures.feature_names
      });

      // Display each recommendation in the UI
      const li = document.createElement("li");
      const link = document.createElement("a");
      link.href = bookInfo.link;
      link.target = "_blank";
      link.textContent = `${bookInfo.title} by ${bookInfo.authors.join(', ')}`;
      li.appendChild(link);
      recommendationsList.appendChild(li);
    });

    try {
      let explanationData;
      if (tab === "lime") {
        explanationData = await fetchLimeExplanation('lime', recommendations);
        displayLimeExplanation(explanationData, 'lime');
      } else if (tab === "anchor") {
        explanationData = await fetchAnchorExplanation('anchor', recommendations, selectedBook.description);
        displayAnchorExplanation(explanationData);
      }
    } catch (error) {
      console.error("Error fetching explanation:", error);
    }


    function capitalize(word) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }

    function validateRecommendations(recommendations) {
      return recommendations.every(rec =>
                                       rec &&
                                       typeof rec.title === 'string' &&
                                       Array.isArray(rec.vectorized_descriptions) &&
                                       Array.isArray(rec.feature_names) &&
                                       rec.vectorized_descriptions.length === rec.feature_names.length
      );
    }

    async function fetchLimeExplanation(type, recommendations) {
      // Validate recommendations before proceeding
      if (!validateRecommendations(recommendations)) {
        console.error("Invalid recommendations structure.");
        return {error: "Invalid recommendations structure"};
      }

      const url = `/${type}-explanation`;

      const response = await fetch(url, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({recommendations}) // Send recommendations as the body
      });

      if (!response.ok) {
        console.error(`Error: ${response.status} - ${response.statusText}`);
        return {error: `Failed to fetch explanation for ${type}`};
      }
      const explanationData = await response.json();
      console.log("Explanation data received:", explanationData); // Log explanation data
      return explanationData;
    }

    async function fetchAnchorExplanation(type, recommendations, originalDescription = "") {
      const url = `/${type}-explanation`;

      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ recommendations, original_description: originalDescription }),
        });

        console.log("Raw response object:", response);

        if (!response.ok) {
          console.error(`Error: ${response.status} - ${response.statusText}`);
          return { error: `Failed to fetch explanation for ${type}` };
        }

        const explanationData = await response.json();
        console.log("Explanation data received:", explanationData);
        return explanationData;
      } catch (error) {
        console.error("Error during fetchAnchorExplanation:", error);
        return { error: "An error occurred while fetching Anchor explanations." };
      }
    }



    function displayAnchorExplanation(data) {
      const explanationContainer = document.getElementById('anchorExplanationList');
      explanationContainer.innerHTML = ''; // Clear previous explanations

      if (!Array.isArray(data) || data.length === 0) {
        console.error("No valid Anchor explanation data received:", data);
        explanationContainer.innerHTML = '<li>No Anchor explanations available. Please try refreshing the page and searching again.</li>';
        return;
      }

      data.forEach((explanation, index) => {
        console.log("Processing explanation:", explanation);

        const title = document.createElement('h3');
        title.textContent = explanation.title || `Recommendation ${index + 1}`;

        const anchorWords = document.createElement('p');
        anchorWords.textContent = `Anchor Words: ${explanation.anchor_words || 'None'}`;

        const precision = document.createElement('p');
        const precisionValue = explanation.precision;
        console.log("Precision value:", precisionValue);
        if (typeof precisionValue === "number") {
          precision.textContent = `Precision: ${precisionValue.toFixed(2)}`;
        } else {
          precision.textContent = "Precision: N/A";
          console.warn(`Invalid precision value for explanation ${index + 1}:`, precisionValue);
        }

        explanationContainer.appendChild(title);
        explanationContainer.appendChild(anchorWords);
        explanationContainer.appendChild(precision);
      });
    }





    function displayLimeExplanation(data, type) {
      console.log("Data passed to displayLimeExplanation:", data); // Log the initial data received

      const explanationContainer = document.getElementById('limeExplanationList');

      if (!explanationContainer) {
        console.error("limeExplanationList element not found in DOM");
        return;
      }

      explanationContainer.innerHTML = ''; // Clear previous explanations

      if (!Array.isArray(data)) {
        console.error("Invalid data format for explanation display. Expected array, received:", typeof data);
        explanationContainer.innerHTML = "<li>No explanation data available.</li>";
        return;
      }

      console.log(`Number of explanations to display: ${data.length}`);

      data.forEach((explanationData, idx) => {
        console.log(`Processing explanation #${idx + 1}:`, explanationData);

        const recommendationTitle = explanationData.title || `Recommendation ${idx + 1}`;
        const titleElement = document.createElement('h3');
        titleElement.textContent = recommendationTitle;

        const generalExplanation = document.createElement('p');
        generalExplanation.textContent = explanationData.general_explanation || "No general explanation provided.";

        const explanationList = document.createElement('ul');
        const explanationOutput = explanationData.explanation_output || [];

        if (Array.isArray(explanationOutput) && explanationOutput.length > 0) {
          explanationOutput.forEach(item => {
            const listItem = document.createElement('li');
            listItem.textContent = item; // Directly render the string
            explanationList.appendChild(listItem);
          });
        } else {
          const noExplanationItem = document.createElement('li');
          noExplanationItem.textContent = "No significant features found in the explanation.";
          explanationList.appendChild(noExplanationItem);
        }

        explanationContainer.appendChild(titleElement);
        explanationContainer.appendChild(generalExplanation);
        explanationContainer.appendChild(explanationList);
      });
    }








    function normalizeAuthorName(name) {
      return name.replace(/[^\w]/g, '').toLowerCase().trim(); // Remove punctuation and spaces, convert to lowercase
    }

    function normalizeTitle(title) {
      return title.replace(/[^\w\s]/g, '').toLowerCase().trim(); // Remove punctuation, convert to lowercase, trim spaces
    }

    function filterRecommendations(processedBooks, tfidf_matrix, vectorized_descriptions, includeSameAuthor) {
      const finalRecommendations = [];
      const similarityScoreThreshold = 0.03;

      // Check that vectorized_descriptions is defined and accessible
      if (!vectorized_descriptions || vectorized_descriptions.length === 0) {
        console.error("Vectorized descriptions are missing or empty.");
        return [];
      }

      // Get the normalized original title for comparison
      const originalTitle = normalizeTitle(processedBooks[0].title);
      const originalTitleTokens = originalTitle.split(" ");

      processedBooks.forEach((book, index) => {
        const bookVector = tfidf_matrix[index];
        const similarity = cosineSimilarity(vectorized_descriptions, bookVector);

        if (similarity > similarityScoreThreshold) {
          // Compare authors using normalized names
          const isSameAuthor = includeSameAuthor || !book.authors.some(author =>
                                                                           processedBooks[0].authors.some(mainAuthor =>
                                                                                                              normalizeAuthorName(author)
                                                                                                              === normalizeAuthorName(mainAuthor)
                                                                           )
          );

          // Tokenize and normalize the current book's title
          const currentTitleTokens = normalizeTitle(book.title).split(" ");

          // Check if none of the original title's tokens are in the current title
          const isDifferentTitle = !originalTitleTokens.some(token => currentTitleTokens.includes(token));

          if (isSameAuthor && isDifferentTitle) {
            finalRecommendations.push(book);
          }
        }
      });

      return finalRecommendations.slice(0, 5); // Limit to top 5 recommendations
    }

    function cosineSimilarity(vecA, vecB) {
      const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
      const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
      const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
      return dotProduct / (magnitudeA * magnitudeB);
    }
  }

</script>
</body>
</html>
