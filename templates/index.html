<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/static/styles.css">
    <title>Book Recommendation</title>
</head>
<body>

    <div class="container">
        <h1>Book Recommendation System</h1>


<div class="tabs">
  <button class="tab" data-tab="noXAI">No XAI</button>
  <button class="tab" data-tab="lime">LIME</button>
  <button class="tab" data-tab="shap">SHAP</button>
  <button class="tab" data-tab="counterfactual">Counterfactual</button>
</div>

<div id="tabContentContainer">
  <!-- No XAI Tab -->
  <div id="noXAI" class="tab-content" style="display:none;">
    <h2>No XAI Explanation</h2>
    <input type="text" id="bookTitleNoXAI" placeholder="Enter a book title">
    <div class="toggle-label">
      <label>
        <input type="checkbox" id="includeSameAuthorNoXAI" checked>
        Include recommendations by the same author
      </label>
    </div>
    <button onclick="getRecommendations('noXAI')">Get Recommendations</button>
    <ul id="recommendationsNoXAI"></ul>
    <div id="noXAIExplanation" class="noXAI-explanation" style="display:none;">
      <h2>No XAI Explanation for <span id="explainedTitleNoXAI"></span></h2>
      <ul id="noXAIExplanationList"></ul>
    </div>
  </div>

  <!-- LIME Tab -->
  <div id="lime" class="tab-content" style="display:none;">
    <h2>LIME Explanation</h2>
    <input type="text" id="bookTitleLime" placeholder="Enter a book title">
    <div class="toggle-label">
      <label>
        <input type="checkbox" id="includeSameAuthorLime" checked>
        Include recommendations by the same author
      </label>
    </div>
    <button onclick="getRecommendations('lime')">Get Recommendations</button>
    <ul id="recommendationsLime"></ul>
    <div id="limeExplanation" class="lime-explanation" style="display:none;">
      <h2>LIME Explanation for <span id="explainedTitleLime"></span></h2>
      <ul id="limeExplanationList"></ul>
    </div>
  </div>

  <!-- SHAP Tab -->
  <div id="shap" class="tab-content" style="display:none;">
    <h2>SHAP Explanation</h2>
    <input type="text" id="bookTitleShap" placeholder="Enter a book title">
    <div class="toggle-label">
      <label>
        <input type="checkbox" id="includeSameAuthorShap" checked>
        Include recommendations by the same author
      </label>
    </div>
    <button onclick="getRecommendations('shap')">Get Recommendations</button>
    <ul id="recommendationsShap"></ul>
    <div id="shapExplanation" class="shap-explanation" style="display:none;">
      <h2>SHAP Explanation for <span id="explainedTitleShap"></span></h2>
      <ul id="shapExplanationList"></ul>
    </div>
  </div>

  <!-- Counterfactual Tab -->
  <div id="counterfactual" class="tab-content" style="display:none;">
    <h2>Counterfactual Explanation</h2>
    <input type="text" id="bookTitleCounterfactual" placeholder="Enter a book title">
    <div class="toggle-label">
      <label>
        <input type="checkbox" id="includeSameAuthorCounterfactual" checked>
        Include recommendations by the same author
      </label>
    </div>
    <button onclick="getRecommendations('counterfactual')">Get Recommendations</button>
    <ul id="recommendationsCounterfactual"></ul>
    <div id="counterfactualExplanation" class="counterfactual-explanation" style="display:none;">
      <h2>Counterfactual Explanation for <span id="explainedTitleCounterfactual"></span></h2>
      <ul id="counterfactualExplanationList"></ul>
    </div>
  </div>
</div>
<script>

  const tabs = document.querySelectorAll(".tab");
  tabs.forEach(tab => {
    tab.addEventListener("click", event => {
      const tabName = event.target.getAttribute("data-tab");
      openTab(tabName, event);
    });
  });
  // event listeners for recommendation buttons
  const recommendationButtons = document.querySelectorAll(".recommend-button");
  recommendationButtons.forEach(button => {
    button.addEventListener("click", event => {
      const tabId = event.target.getAttribute("data-tab");
      getRecommendations(tabId);
    });
  });

  // Function to handle tab switching
  function openTab(tabName, evt) {
    const tabContents = document.getElementsByClassName("tab-content");

    // Hide all tab contents
    for (let i = 0; i < tabContents.length; i++) {
      tabContents[i].style.display = "none";
    }

    // Show the current tab content
    document.getElementById(tabName).style.display = "block";

    // Remove "active" class from all tabs
    const tabs = document.getElementsByClassName("tab");
    for (let i = 0; i < tabs.length; i++) {
      tabs[i].classList.remove("active");
    }

    // Add "active" class to the clicked tab
    evt.currentTarget.classList.add("active");
  }

  //  clean and filter book descriptions
  function filterDescription(description) {
    const stopwords = ["the", "a", "an", "in", "on", "and", "or", "of", "to", "is", "for", "by"]; // Add more stopwords as needed
    return description
        .toLowerCase()
        .replace(/[^a-z\s]/g, '') // Remove non-alphabet characters
        .split(/\s+/) // Split by whitespace
        .filter(word => word.length > 0 && !stopwords.includes(word)) // Filter out stopwords and empty words
        .join(' '); // Rejoin the words
  }

  // Vectorises keywords for cosine similarity
  function vectorizeKeywords(keywords, allDocuments) {
    const documents = allDocuments.map(doc => doc.split(' '));
    const tfidfVectors = computeTFIDF(documents);

    const keywordsArray = keywords.split(' ');
    const vector = {};

    for (let i = 0; i < tfidfVectors.length; i++) {
      for (let word in tfidfVectors[i]) {
        vector[word] = tfidfVectors[i][word];
      }
    }

    // Handle case where the keywords result in an empty or single-word vector
    if (keywordsArray.length === 0) {
      console.error("Empty or invalid keyword vector");
      return new Array(Object.keys(vector).length).fill(0);  // Return a zero-filled vector of the same length
    }

    // Logging statements outside the loop
    console.log(`Vectorizing keywords: ${keywords}`);
    console.log(`All descriptions length: ${allDocuments.length}`);

    return keywordsArray.map(word => vector[word] || 0);
  }

  // Computes term frequency (TF) for each word in a document
  function computeTF(words) {
    const tf = {};
    const totalWords = words.length;
    words.forEach(word => {
      tf[word] = (tf[word] || 0) + 1;
    });
    for (let word in tf) {
      tf[word] = tf[word] / totalWords;
    }
    return tf;
  }

  // Computes inverse document frequency (IDF)
  function computeIDF(documents) {
    const idf = {};
    const totalDocs = documents.length;
    const wordDocCount = {};

    documents.forEach(doc => {
      const uniqueWords = new Set(doc);
      uniqueWords.forEach(word => {
        wordDocCount[word] = (wordDocCount[word] || 0) + 1;
      });
    });

    for (let word in wordDocCount) {
      idf[word] = Math.log(totalDocs / (1 + wordDocCount[word]));
    }
    return idf;
  }

  // computes TF-IDF vectors for a set of documents
  function computeTFIDF(documents) {
    const idf = computeIDF(documents);
    return documents.map(doc => {
      const tf = computeTF(doc);
      const tfidf = {};
      for (let word in tf) {
        tfidf[word] = tf[word] * idf[word];
      }
      return tfidf;
    });
  }

// computes cosine similarity between two vectors
  function cosineSimilarity(vecA, vecB) {
    const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
    const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
    const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));

// Logging before return
    console.log(`Cosine similarity calculation for vectors: ${vecA} and ${vecB}`);

    return dotProduct / (magnitudeA * magnitudeB);
  }

//main function for getting recommendations
  async function getRecommendations(model) {
    const inputId = `bookTitle${model.charAt(0).toUpperCase() + model.slice(1)}`;
    const bookTitle = document.getElementById(inputId).value.toLowerCase();
    const recommendationsId = `recommendations${model.charAt(0).toUpperCase() + model.slice(1)}`;
    const recommendationsList = document.getElementById(recommendationsId);
    recommendationsList.innerHTML = '';  // Clear previous recommendations

    const includeSameAuthor = document.getElementById(`includeSameAuthor${model.charAt(0).toUpperCase() + model.slice(1)}`).checked;

//fetchbook data from Google Books API
    const googleApiKey = 'AIzaSyDQTQy3LT7BOO_LLClbWuEvqiPbUbWWKBs';
    const googleApiUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(bookTitle)}&maxResults=40&key=${googleApiKey}`;

    let books;
    try {
      const apiResponse = await fetch(googleApiUrl);
      const apiData = await apiResponse.json();
      books = apiData.items || [];
    } catch (error) {
      console.error("Error fetching books from Google API", error);
      return;
    }

    const processedBooks = books.map(book => ({
      title: book.volumeInfo.title || "Unknown Title",
      authors: book.volumeInfo.authors || [],
      description: book.volumeInfo.description || "No description available",
      link: book.volumeInfo.infoLink || "#"
    }));

//this it to find the selected book (user input)
    const selectedBook = processedBooks.find(book => book.title.toLowerCase() === bookTitle);

    if (!selectedBook) {
      console.error("Selected book not found");
      return;
    }

    const allDescriptions = processedBooks.map(book => filterDescription(book.description));
    const keywordVector = vectorizeKeywords(selectedBook.description, allDescriptions);

//recommendations based on cosine similarity
    const seenTitles = new Set();
    let recommendations = [];


    processedBooks.forEach((book, idx) => {
      const bookVector = vectorizeKeywords(filterDescription(book.description), allDescriptions);
      const similarity = cosineSimilarity(keywordVector, bookVector);

      const normalizedTitle = book.title.toLowerCase();
      const isSameAuthor = book.authors.some(author => processedBooks[0].authors.includes(author));

      if (similarity > 0.15 && normalizedTitle !== bookTitle) { //not the same book
        if (!seenTitles.has(normalizedTitle)) {
          if (includeSameAuthor || !isSameAuthor) { // check for the same author toggle on/off
            seenTitles.add(normalizedTitle);
            recommendations.push(book);
          }
        }
      }
    });
      
  // Sort out recommendations based by highest similarity, to prioritize better matches at top of list
  recommendations.sort((a, b) => b.similarity - a.similarity);

  //If have fewer than 10 recommendations, continue adding until reaches 10
  while (recommendations.length < 10 && processedBooks.length > recommendations.length) {
    const remainingBooks = processedBooks.filter(book => !seenTitles.has(book.title.toLowerCase()) && book.title.toLowerCase() !== bookTitle);
    if (remainingBooks.length === 0) break;

    const nextBook = remainingBooks.shift();
    seenTitles.add(nextBook.title.toLowerCase());
    recommendations.push({book: nextBook, similarity: 0});  // Add with 0 similarity (since we ran out of good matches)
  }

  //Limit 10 recommendations
  recommendations = recommendations.slice(0, 10);

//empty recommendations
    if (recommendations.length === 0) {
      recommendationsList.innerHTML = "<li>No valid recommendations found.</li>";
      return;
    }

//display recommendations in UI
    recommendations.forEach(bookInfo => {
      const li = document.createElement("li");
      const link = document.createElement("a");
      link.href = bookInfo.link;
      link.target = "_blank";
      link.textContent = `${bookInfo.title} by ${bookInfo.authors.join(', ')}`;
      li.appendChild(link);
      recommendationsList.appendChild(li);
    });

  }


</script>
</body>
</html>
