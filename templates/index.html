<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="static/styles.css">
  <title>Book Recommendation</title>
</head>
<body>
<div class="container">
  <h1>Book Recommendation System</h1>
  <div class="tabs">
    <button class="tab" data-tab="noXAI">No XAI</button>
    <button class="tab" data-tab="lime">LIME</button>
    <button class="tab" data-tab="shap">SHAP</button>
    <button class="tab" data-tab="counterfactual">Counterfactual</button>
  </div>
  <div id="tabContentContainer">
    <!-- Tab content for No XAI, LIME, SHAP, Counterfactual -->
    <div id="noXAI" class="tab-content" style="display:none;">
      <h2>No XAI Explanation</h2>
      <input type="text" id="bookTitleNoXAI" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorNoXAI" checked>
        <label for="includeSameAuthorNoXAI">Include recommendations by the same author</label>
      </div>
      <button onclick="getRecommendations('noXAI')">Get Recommendations</button>
      <ul id="recommendationsNoXAI"></ul>
    </div>
    <div id="lime" class="tab-content" style="display:none;">
      <h2>LIME Explanation</h2>
      <input type="text" id="bookTitleLime" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorLime" checked>
        <label for="includeSameAuthorLime">Include recommendations by the same author</label>
      </div>
      <button onclick="getRecommendations('lime')">Get Recommendations</button>
      <ul id="recommendationsLime"></ul>
      <div id="limeExplanation" style="display:none;">
        <h2>LIME Explanation for <span id="explainedTitleLime"></span></h2>
        <ul id="limeExplanationList"></ul>
      </div>
    </div>
    <!-- Repeat similar structure for SHAP and Counterfactual tabs -->
  </div>
</div>

<script>
  window.addEventListener("DOMContentLoaded", initTabs);

  function initTabs() {
    const tabButtons = document.querySelectorAll(".tab");
    showTabContent("noXAI");
    document.querySelector('.tab[data-tab="noXAI"]').classList.add("active");
    tabButtons.forEach(button => button.addEventListener("click", () => handleTabClick(button.dataset.tab)));
  }

  function handleTabClick(tabId) {
    document.querySelectorAll(".tab").forEach(button => button.classList.remove("active"));
    document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add("active");
    showTabContent(tabId);
  }

  function showTabContent(tabId) {
    document.querySelectorAll(".tab-content").forEach(content => {
      content.style.display = content.id === tabId ? "block" : "none";
    });
  }

  async function getRecommendations(tab) {
    console.log(`Fetching recommendations for tab: ${tab}`);
    const inputId = `bookTitle${capitalize(tab)}`;
    const bookTitle = document.getElementById(inputId).value.toLowerCase();
    const recommendationsId = `recommendations${capitalize(tab)}`;
    const recommendationsList = document.getElementById(recommendationsId);
    recommendationsList.innerHTML = '';

    const includeSameAuthor = document.getElementById(`includeSameAuthor${capitalize(tab)}`).checked;
    const googleApiKey = 'AIzaSyDQTQy3LT7BOO_LLClbWuEvqiPbUbWWKBs'; // Replace with your actual API key
    const googleApiUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(bookTitle)}&maxResults=40&key=${googleApiKey}`;

    let books;
    try {
      const apiResponse = await fetch(googleApiUrl);
      const apiData = await apiResponse.json();
      books = apiData.items || [];
      console.log("Books fetched from Google API:", books);
    } catch (error) {
      console.error("Error fetching books from Google API", error);
      return;
    }

    const processedBooks = books.map(book => ({
      title: book.volumeInfo.title || "Unknown Title",
      authors: book.volumeInfo.authors || [],
      description: book.volumeInfo.description || "No description available",
      link: book.volumeInfo.infoLink || "#"
    }));

    const descriptions = processedBooks.map(book => book.description);
    const selectedBook = processedBooks.find(book => book.title.toLowerCase() === bookTitle.toLowerCase());

    if (!selectedBook) {
      console.error("Selected book not found in API response");
      return;
    }

    let tfidfData;
    try {
      const response = await fetch("/vectorize-descriptions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ descriptions })
      });
      tfidfData = await response.json();
      console.log("TF-IDF vectorization data received from backend:", tfidfData);
    } catch (error) {
      console.error("Error during TF-IDF vectorization:", error);
      return;
    }

    const { tfidf_matrix, feature_names, description_vector } = tfidfData;
    const finalRecommendations = filterRecommendations(processedBooks, tfidf_matrix, description_vector, includeSameAuthor);
    console.log("Final filtered recommendations:", finalRecommendations);

    if (finalRecommendations.length === 0) {
      recommendationsList.innerHTML = "<li>No valid recommendations found.</li>";
      return;
    }

    finalRecommendations.forEach(bookInfo => {
      const li = document.createElement("li");
      const link = document.createElement("a");
      link.href = bookInfo.link;
      link.target = "_blank";
      link.textContent = `${bookInfo.title} by ${bookInfo.authors.join(', ')}`;
      li.appendChild(link);
      recommendationsList.appendChild(li);
    });

    if (!selectedBook) {
      console.error("Selected book not found in API response");
      return;
    }

    // Use selectedBook.description as bookDescription
    const bookDescription = selectedBook.description;

    // Create an array of descriptions for all books as allDescriptions
    const allDescriptions = processedBooks.map(book => book.description);

    try {
      if (tab === "lime") {
        const limeExplanation = await fetchExplanation('lime', selectedBook.title, bookDescription, allDescriptions);
        displayExplanation(limeExplanation, 'lime');
      } else if (tab === "shap") {
        const shapExplanation = await fetchExplanation('shap', selectedBook.title, bookDescription, allDescriptions);
        displayExplanation(shapExplanation, 'shap');
      } else if (tab === "counterfactual") {
        const counterfactualExplanation = await fetchExplanation('counterfactual', selectedBook.title, bookDescription, allDescriptions);
        displayExplanation(counterfactualExplanation, 'counterfactual');
      }
    } catch (error) {
      console.error(`Error fetching explanation for ${tab} tab:`, error);
    }

  function capitalize(word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }

  async function fetchExplanation(type, bookTitle, bookDescription, allDescriptions) {
    const url = `/${type}-explanation`;
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
                             book_title: bookTitle,
                             book_description: bookDescription,
                             all_books: allDescriptions
                           })
    });
    return response.json();
  }

  function displayExplanation(data, type) {
    // Update the explanation title with the book title
    document.getElementById(`explainedTitle${capitalize(type)}`).textContent = data.title || "Unknown Title";

    const explanationListElement = document.getElementById(`${type}ExplanationList`);
    explanationListElement.innerHTML = ''; // Clear previous explanations

    // Add general explanation
    const generalExplanationItem = document.createElement('li');
    generalExplanationItem.textContent = data.general_explanation || "No general explanation provided.";
    explanationListElement.appendChild(generalExplanationItem);

    // Extract and display the specific explanation output array
    const explanationOutput = data[`${type}_output`];
    if (Array.isArray(explanationOutput)) {
      explanationOutput.forEach(item => {
        const listItem = document.createElement('li');
        listItem.textContent = `${item[0]}: ${item[1].toFixed(2)}`; // Word and weight
        explanationListElement.appendChild(listItem);
      });
    } else {
      // Handle cases where explanation output is missing or undefined
      const errorItem = document.createElement('li');
      errorItem.textContent = "Explanation output not available.";
      explanationListElement.appendChild(errorItem);
    }

    // Show the explanation section
    document.getElementById(`${type}Explanation`).style.display = 'block';
  }


  function filterRecommendations(processedBooks, tfidf_matrix, description_vector, includeSameAuthor) {
    const finalRecommendations = [];
    const similarityScoreThreshold = 0.2;

    processedBooks.forEach((book, index) => {
      const bookVector = tfidf_matrix[index];
      const similarity = cosineSimilarity(description_vector, bookVector);

      if (similarity > similarityScoreThreshold) {
        const isSameAuthor = includeSameAuthor || !book.authors.some(author => processedBooks[0].authors.includes(author));
        if (isSameAuthor) {
          finalRecommendations.push(book);
        }
      }
    });

    return finalRecommendations.slice(0, 5); // Limit to top 5 recommendations
  }

  function cosineSimilarity(vecA, vecB) {
    const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
    const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
    const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
    return dotProduct / (magnitudeA * magnitudeB);
  }
</script>
</body>
</html>
