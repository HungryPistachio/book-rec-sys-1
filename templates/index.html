<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="static/styles.css">
  <title>Book Recommendation</title>
</head>
<body>
<div class="container">
  <h1>Book Recommendation System</h1>
  <div class="tabs">
    <button class="tab" data-tab="noXAI">No XAI</button>
    <button class="tab" data-tab="lime">LIME</button>
    <button class="tab" data-tab="shap">SHAP</button>
    <button class="tab" data-tab="counterfactual">Counterfactual</button>
  </div>
  <div id="tabContentContainer">
    <!-- Tab content for No XAI, LIME, SHAP, Counterfactual -->
    <div id="noXAI" class="tab-content" style="display:none;">
      <h2>No XAI Explanation</h2>
      <input type="text" id="bookTitleNoXAI" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorNoXAI" checked>
        <label for="includeSameAuthorNoXAI">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="noXAI">Get Recommendations</button>
      <ul id="recommendationsNoXAI"></ul>
    </div>
    <div id="lime" class="tab-content" style="display:none;">
      <h2>LIME Explanation</h2>
      <input type="text" id="bookTitleLime" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorLime" checked>
        <label for="includeSameAuthorLime">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="lime">Get Recommendations</button>
      <ul id="recommendationsLime"></ul>
      <div id="limeExplanation" style="display:none;">
        <h2>LIME Explanation for <span id="explainedTitleLime"></span></h2>
          <p id="limeExplanationGeneral">These recommendations are formed using the description of your original book and using this to search for similar books.
          The LIME explanation displays the relevant words within the description and the weight of these words.
          The higher the number the more the word helped to identify this book as a good recommendation.</p>
        <ul id="limeExplanationList"></ul>
      </div>
    </div>
    <div id="shap" class="tab-content" style="display:none;">
      <h2>SHAP Explanation</h2>
      <input type="text" id="bookTitleShap" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorShap" checked>
        <label for="includeSameAuthorShap">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="shap">Get Recommendations</button>
      <ul id="recommendationsShap"></ul>
      <div id="shapExplanation" style="display:none;">
        <h2>SHAP Explanation for <span id="explainedTitleShap"></span></h2>
        <ul id="shapExplanationList"></ul>
      </div>
    </div>
    <div id="counterfactual" class="tab-content" style="display:none;">
      <h2>Counterfactual Explanation</h2>
      <input type="text" id="bookTitleCounterfactual" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorCounterfactual" checked>
        <label for="includeSameAuthorCounterfactual">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="counterfactual">Get Recommendations</button>
      <ul id="recommendationsCounterfactual"></ul>
      <div id="counterfactualExplanation" style="display:none;">
        <h2>Counterfactual Explanation for <span id="explainedTitleCounterfactual"></span></h2>
        <ul id="counterfactualExplanationList"></ul>
      </div>
    </div>
  </div>
</div>
<script>
  window.addEventListener("DOMContentLoaded", initTabs);
  document.querySelectorAll('.get-recommendations-button').forEach(button => {
    button.addEventListener('click', async () => {
      const tab = button.dataset.tab;
      await getRecommendations(tab);
    });
  });
  function initTabs() {
    const tabButtons = document.querySelectorAll(".tab");
    showTabContent("noXAI");
    document.querySelector('.tab[data-tab="noXAI"]').classList.add("active");
    tabButtons.forEach(button => button.addEventListener("click", () => handleTabClick(button.dataset.tab)));
  }

  function handleTabClick(tabId) {
    document.querySelectorAll(".tab").forEach(button => button.classList.remove("active"));
    document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add("active");
    showTabContent(tabId);
  }

  function showTabContent(tabId) {
    document.querySelectorAll(".tab-content").forEach(content => {
      content.style.display = content.id === tabId ? "block" : "none";
    });
  }

  // Function to filter non-zero elements in description_vector
  function filterNonZeroFeatures(descriptionVector, featureNames) {
    return descriptionVector.reduce((filteredData, weight, index) => {
      if (weight !== 0) {
        filteredData.description_vector.push(weight);
        filteredData.feature_names.push(featureNames[index]);
      }
      return filteredData;
    }, { description_vector: [], feature_names: [] });
  }

  async function getRecommendations(tab) {
    console.log(`Fetching recommendations for tab: ${tab}`);
    const recommendations = [];
    const inputId = `bookTitle${capitalize(tab)}`;
    const bookTitle = document.getElementById(inputId).value.toLowerCase();
    const recommendationsId = `recommendations${capitalize(tab)}`;
    const recommendationsList = document.getElementById(recommendationsId);
    recommendationsList.innerHTML = '';

    const includeSameAuthor = document.getElementById(`includeSameAuthor${capitalize(tab)}`).checked;
    const googleApiKey = 'AIzaSyDQTQy3LT7BOO_LLClbWuEvqiPbUbWWKBs'; // Replace with your actual API key
    const googleApiUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(bookTitle)}&maxResults=40&key=${googleApiKey}`;

    let books;
    try {
      const apiResponse = await fetch(googleApiUrl);
      const apiData = await apiResponse.json();
      books = apiData.items || [];
      console.log("Books fetched from Google API:", books);
    } catch (error) {
      console.error("Error fetching books from Google API", error);
      return;
    }

    const processedBooks = books.map(book => ({
      title: book.volumeInfo.title || "Unknown Title",
      authors: book.volumeInfo.authors || [],
      description: book.volumeInfo.description || "No description available",
      link: book.volumeInfo.infoLink || "#"
    }));

    const descriptions = processedBooks.map(book => book.description);
    const selectedBook = processedBooks.find(book => book.title.toLowerCase() === bookTitle.toLowerCase());

    if (!selectedBook) {
      console.error("Selected book not found in API response");
      return;
    }

    let tfidfData;
    try {
      const response = await fetch("/vectorize-descriptions", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ descriptions })
      });
      tfidfData = await response.json();
      console.log("TF-IDF vectorization data received from backend:", tfidfData);
    } catch (error) {
      console.error("Error during TF-IDF vectorization:", error);
      return;
    }

    const { tfidf_matrix, feature_names, description_vector } = tfidfData;

    // Generate final recommendations
    const finalRecommendations = filterRecommendations(processedBooks, tfidf_matrix, description_vector, includeSameAuthor);
    console.log("Final filtered recommendations:", finalRecommendations);

    if (finalRecommendations.length === 0) {
      recommendationsList.innerHTML = "<li>No valid recommendations found.</li>";
      return;
    }

    finalRecommendations.forEach((bookInfo, index) => {
      const bookVector = tfidf_matrix[index];
      const nonZeroFeatures = filterNonZeroFeatures(bookVector, feature_names);

      recommendations.push({
                             title: bookInfo.title,
                             description_vector: nonZeroFeatures.description_vector,
                             feature_names: nonZeroFeatures.feature_names
                           });

      // Display each recommendation in the UI
      const li = document.createElement("li");
      const link = document.createElement("a");
      link.href = bookInfo.link;
      link.target = "_blank";
      link.textContent = `${bookInfo.title} by ${bookInfo.authors.join(', ')}`;
      li.appendChild(link);
      recommendationsList.appendChild(li);
    });

    try {
      let explanationData;
      if (tab === "lime") {
        explanationData = await fetchExplanation('lime', recommendations);
        document.getElementById("limeExplanation").style.display = "block";
      } else if (tab === "shap") {
        explanationData = await fetchExplanation('shap', recommendations);
        document.getElementById("shapExplanation").style.display = "block";
      } else if (tab === "counterfactual") {
        explanationData = await fetchExplanation('counterfactual', recommendations);
        document.getElementById("counterfactualExplanation").style.display = "block";
      }

      // Display explanation for the active tab
      displayExplanation(explanationData, tab);
    } catch (error) {
      console.error(`Error fetching explanation for ${tab} tab:`, error);
    }
  }



    function capitalize(word) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }



  function validateRecommendations(recommendations) {
    return recommendations.every(rec =>
                                     rec &&
                                     typeof rec.title === 'string' &&
                                     Array.isArray(rec.description_vector) &&
                                     Array.isArray(rec.feature_names) &&
                                     rec.description_vector.length === rec.feature_names.length
    );
  }
  async function fetchExplanation(type, recommendations) {
    // Validate recommendations before proceeding
    if (!validateRecommendations(recommendations)) {
      console.error("Invalid recommendations structure.");
      return { error: "Invalid recommendations structure" };
    }

    const url = `/${type}-explanation`;

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ recommendations }) // Send recommendations as the body
    });

    if (!response.ok) {
      console.error(`Error: ${response.status} - ${response.statusText}`);
      return { error: `Failed to fetch explanation for ${type}` };
    }
    const explanationData = await response.json();
    console.log("Explanation data received:", explanationData); // Log explanation data
    return explanationData;
  }






  function displayExplanation(data, type) {
    console.log("Data passed to displayExplanation:", data); // Log explanation data

    const explanationContainer = document.getElementById(`${type}ExplanationList`);
    explanationContainer.innerHTML = ''; // Clear previous explanations

    if (!Array.isArray(data)) {
      console.error("Invalid data format for explanation display");
      explanationContainer.innerHTML = "<li>No explanation data available.</li>";
      return;
    }

    data.forEach((explanationData, idx) => {
      const recommendationTitle = explanationData.title || `Recommendation ${idx + 1}`;

      const titleElement = document.createElement('h3');
      titleElement.textContent = recommendationTitle;

      const generalExplanation = document.createElement('p');
      generalExplanation.textContent = explanationData.general_explanation || "No general explanation provided.";

      const explanationList = document.createElement('ul');

      const explanationOutput = explanationData.explanation_output.filter(item => Math.abs(item[1]) > 0.0); // Only items with non-zero weight
      if (Array.isArray(explanationOutput) && explanationOutput.length > 0) {
        explanationOutput.forEach(item => {
          const listItem = document.createElement('li');

          // Display each weight in scientific notation if very small
          const weight = Math.abs(item[1]) < 1e-2 ? item[1].toExponential(3) : item[1].toFixed(3);

          listItem.textContent = `${item[0]}: ${weight}`;
          explanationList.appendChild(listItem);
        });
      } else {
        const noExplanationItem = document.createElement('li');
        noExplanationItem.textContent = "No significant features found in the explanation.";
        explanationList.appendChild(noExplanationItem);
      }

      explanationContainer.appendChild(titleElement);
      explanationContainer.appendChild(generalExplanation);
      explanationContainer.appendChild(explanationList);
    });
  }





  function normalizeAuthorName(name) {
    return name.replace(/[^\w]/g, '').toLowerCase().trim(); // Remove punctuation and spaces, convert to lowercase
  }
  // Helper function to normalize titles by removing punctuation and converting to lowercase
  // Helper function to normalize titles by removing punctuation, converting to lowercase, and trimming spaces
  function normalizeTitle(title) {
    return title.replace(/[^\w\s]/g, '').toLowerCase().trim(); // Remove punctuation, convert to lowercase, trim spaces
  }

  function filterRecommendations(processedBooks, tfidf_matrix, description_vector, includeSameAuthor) {
    const finalRecommendations = [];
    const similarityScoreThreshold = 0.1;

    // Get the normalized original title for comparison
    const originalTitle = normalizeTitle(processedBooks[0].title);
    const originalTitleTokens = originalTitle.split(" ");

    processedBooks.forEach((book, index) => {
      const bookVector = tfidf_matrix[index];
      const similarity = cosineSimilarity(description_vector, bookVector);

      if (similarity > similarityScoreThreshold) {
        // Compare authors using normalized names
        const isSameAuthor = includeSameAuthor || !book.authors.some(author =>
                                                                         processedBooks[0].authors.some(mainAuthor =>
                                                                                                            normalizeAuthorName(author) === normalizeAuthorName(mainAuthor)
                                                                         )
        );

        // Tokenize and normalize the current book's title
        const currentTitleTokens = normalizeTitle(book.title).split(" ");

        // Check if none of the original title's tokens are in the current title
        const isDifferentTitle = !originalTitleTokens.some(token => currentTitleTokens.includes(token));

        if (isSameAuthor && isDifferentTitle) {
          finalRecommendations.push(book);
        }
      }
    });

    return finalRecommendations.slice(0, 5); // Limit to top 5 recommendations
  }



  function cosineSimilarity(vecA, vecB) {
      const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
      const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
      const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
      return dotProduct / (magnitudeA * magnitudeB);
    }

</script>
</body>
</html>
