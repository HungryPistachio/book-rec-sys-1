<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="/static/styles.css">
  <title>Book Recommendation</title>
</head>
<body>

<div class="container">
  <h1>Book Recommendation System</h1>

  <div class="tabs">
    <button class="tab" data-tab="noXAI">No XAI</button>
    <button class="tab" data-tab="lime">LIME</button>
    <button class="tab" data-tab="shap">SHAP</button>
    <button class="tab" data-tab="counterfactual">Counterfactual</button>
  </div>

  <div id="tabContentContainer">
    <!-- No XAI Tab -->
    <div id="noXAI" class="tab-content" style="display:none;">
      <h2>No XAI Explanation</h2>
      <input type="text" id="bookTitleNoXAI" placeholder="Enter a book title">
      <div class="toggle-label">
        <label>
          <input type="checkbox" id="includeSameAuthorNoXAI" checked>
          Include recommendations by the same author
        </label>
      </div>
      <button onclick="getRecommendations('noXAI')">Get Recommendations</button>
      <ul id="recommendationsNoXAI"></ul>
      <div id="noXAIExplanation" class="noXAI-explanation" style="display:none;">
        <h2>No XAI Explanation for <span id="explainedTitleNoXAI"></span></h2>
        <ul id="noXAIExplanationList"></ul>
      </div>
    </div>

    <!-- LIME Tab -->
    <div id="lime" class="tab-content" style="display:none;">
      <h2>LIME Explanation</h2>
      <input type="text" id="bookTitleLime" placeholder="Enter a book title">
      <div class="toggle-label">
        <label>
          <input type="checkbox" id="includeSameAuthorLime" checked>
          Include recommendations by the same author
        </label>
      </div>
      <button onclick="getRecommendations('lime')">Get Recommendations</button>
      <ul id="recommendationsLime"></ul>
      <div id="limeExplanation" class="lime-explanation" style="display:none;">
        <h2>LIME Explanation for <span id="explainedTitleLime"></span></h2>
        <ul id="limeExplanationList"></ul>
      </div>
    </div>

    <!-- SHAP Tab -->
    <div id="shap" class="tab-content" style="display:none;">
      <h2>SHAP Explanation</h2>
      <input type="text" id="bookTitleShap" placeholder="Enter a book title">
      <div class="toggle-label">
        <label>
          <input type="checkbox" id="includeSameAuthorShap" checked>
          Include recommendations by the same author
        </label>
      </div>
      <button onclick="getRecommendations('shap')">Get Recommendations</button>
      <ul id="recommendationsShap"></ul>
      <div id="shapExplanation" class="shap-explanation" style="display:none;">
        <h2>SHAP Explanation for <span id="explainedTitleShap"></span></h2>
        <ul id="shapExplanationList"></ul>
      </div>
    </div>

    <!-- Counterfactual Tab -->
    <div id="counterfactual" class="tab-content" style="display:none;">
      <h2>Counterfactual Explanation</h2>
      <input type="text" id="bookTitleCounterfactual" placeholder="Enter a book title">
      <div class="toggle-label">
        <label>
          <input type="checkbox" id="includeSameAuthorCounterfactual" checked>
          Include recommendations by the same author
        </label>
      </div>
      <button onclick="getRecommendations('counterfactual')">Get Recommendations</button>
      <ul id="recommendationsCounterfactual"></ul>
      <div id="counterfactualExplanation" class="counterfactual-explanation" style="display:none;">
        <h2>Counterfactual Explanation for <span id="explainedTitleCounterfactual"></span></h2>
        <ul id="counterfactualExplanationList"></ul>
      </div>
    </div>
  </div>

<script>
    const tabs = document.querySelectorAll(".tab");
    tabs.forEach(tab => {
      tab.addEventListener("click", event => {
        const tabName = event.target.getAttribute("data-tab");
        openTab(tabName, event);
      });
    });

    // Function to handle tab switching
    function openTab(tabName, evt) {
      const tabContents = document.getElementsByClassName("tab-content");

      // Hide all tab contents
      for (let i = 0; i < tabContents.length; i++) {
        tabContents[i].style.display = "none";
      }

      // Show the current tab content
      document.getElementById(tabName).style.display = "block";

      // Remove "active" class from all tabs
      const tabs = document.getElementsByClassName("tab");
      for (let i = 0; i < tabs.length; i++) {
        tabs[i].classList.remove("active");
      }

      // Add "active" class to the clicked tab
      evt.currentTarget.classList.add("active");
    }

    // Filter book descriptions by removing stop words
    function filterDescription(description) {
      const stopwords = ["the", "a", "an", "in", "on", "and", "or", "of", "to", "is", "for", "by"]; // Add more stopwords as needed
      return description
          .toLowerCase()
          .replace(/[^a-z\s]/g, '') // Remove non-alphabet characters
          .split(/\s+/) // Split by whitespace
          .filter(word => word.length > 0 && !stopwords.includes(word)) // Filter out stopwords and empty words
          .join(' ');
    }

    // Vectorizes descriptions for cosine similarity
    function vectorizeDescription(description, allDescriptions) {
      const documents = allDescriptions.map(doc => doc.split(' '));
      const tfidfVectors = computeTFIDF(documents);

      const descriptionArray = description.split(' ');
      const vector = {};

      for (let i = 0; i < tfidfVectors.length; i++) {
        for (let word in tfidfVectors[i]) {
          vector[word] = tfidfVectors[i][word];
        }
      }

      // Handle case where the description results in an empty or single-word vector
      if (descriptionArray.length === 0) {
        console.error("Empty or invalid description vector");
        return new Array(Object.keys(vector).length).fill(0);  // Return a zero-filled vector of the same length
      }

      // Logging the extracted keywords for insight
      console.log(`Extracted keywords from user's input book: ${descriptionArray.join(', ')}`);

      return descriptionArray.map(word => vector[word] || 0);
    }

    // Computes term frequency (TF) for each word in a document
    function computeTF(words) {
      const tf = {};
      const totalWords = words.length;
      words.forEach(word => {
        tf[word] = (tf[word] || 0) + 1;
      });
      for (let word in tf) {
        tf[word] = tf[word] / totalWords;
      }
      return tf;
    }

    // Computes inverse document frequency (IDF)
    function computeIDF(documents) {
      const idf = {};
      const totalDocs = documents.length;
      const wordDocCount = {};

      documents.forEach(doc => {
        const uniqueWords = new Set(doc);
        uniqueWords.forEach(word => {
          wordDocCount[word] = (wordDocCount[word] || 0) + 1;
        });
      });

      for (let word in wordDocCount) {
        idf[word] = Math.log(totalDocs / (1 + wordDocCount[word]));
      }
      return idf;
    }

    // Computes TF-IDF vectors for a set of documents
    function computeTFIDF(documents) {
      const idf = computeIDF(documents);
      return documents.map(doc => {
        const tf = computeTF(doc);
        const tfidf = {};
        for (let word in tf) {
          tfidf[word] = tf[word] * idf[word];
        }
        return tfidf;
      });
    }

    // Computes cosine similarity between two vectors
    function cosineSimilarity(vecA, vecB) {
      const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
      const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
      const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));

      return dotProduct / (magnitudeA * magnitudeB);
    }

    // Fetches recommendations from the Google Books API and processes based on description similarity
    async function getRecommendations(model) {
      const inputId = `bookTitle${model.charAt(0).toUpperCase() + model.slice(1)}`;
      const bookTitle = document.getElementById(inputId).value.toLowerCase();
      const recommendationsId = `recommendations${model.charAt(0).toUpperCase() + model.slice(1)}`;
      const recommendationsList = document.getElementById(recommendationsId);
      recommendationsList.innerHTML = '';  // Clear previous recommendations

      const includeSameAuthor = document.getElementById(`includeSameAuthor${model.charAt(0).toUpperCase() + model.slice(1)}`).checked;

      // Fetch book data from Google Books API
      const googleApiKey = 'YOUR_API_KEY';
      const googleApiUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(bookTitle)}&maxResults=40&key=${googleApiKey}`;

      let books;
      try {
        const apiResponse = await fetch(googleApiUrl);
        const apiData = await apiResponse.json();
        books = apiData.items || [];
      } catch (error) {
        console.error("Error fetching books from Google API", error);
        return;
      }

      const processedBooks = books.map(book => ({
        title: book.volumeInfo.title || "Unknown Title",
        authors: book.volumeInfo.authors || [],
        description: book.volumeInfo.description || "No description available",
        link: book.volumeInfo.infoLink || "#"
      }));

      // Find the selected book (first book that matches user input)
      const selectedBook = processedBooks.find(book => book.title.toLowerCase() === bookTitle);

      if (!selectedBook) {
        console.error("Selected book not found");
        return;
      }

      const allDescriptions = processedBooks.map(book => filterDescription(book.description));
      const inputBookVector = vectorizeDescription(filterDescription(selectedBook.description), allDescriptions);

      // Set to track seen titles
      const seenTitles = new Set();
      const recommendations = [];
      let similarityScore = 0.2;

      // Function to add recommendations based on description similarity
      function addRecommendations(similarityScore) {
        let initialLength = recommendations.length; // Track length before adding

        processedBooks.forEach((book) => {
          const bookVector = vectorizeDescription(filterDescription(book.description), allDescriptions);
          const similarity = cosineSimilarity(inputBookVector, bookVector);

          const normalizedTitle = book.title.toLowerCase();
          const isSameAuthor = book.authors.some(author => processedBooks[0].authors.includes(author));

          if (similarity > similarityScore && normalizedTitle !== bookTitle && !normalizedTitle.includes(bookTitle)) { // Exclude similar/same titles
            if (!seenTitles.has(normalizedTitle)) {
              if (includeSameAuthor || !isSameAuthor) { // Respect the same author toggle
                seenTitles.add(normalizedTitle);
                recommendations.push(book);
              }
            }
          }
        });
        return recommendations.length > initialLength; // Return true if new recommendations were added
      }

      // Add initial recommendations
      addRecommendations(similarityScore);

      // If recommendations are fewer than 5, rerun the logic only if new books were added
      let attempts = 0;
      while (recommendations.length < 5 && attempts < 8) {
        if (!addRecommendations(similarityScore)) {
          break; // Exit if no new recommendations were added in this round
        }
        similarityScore -= 0.02;
        attempts++; // Prevent an infinite loop by limiting attempts
      }

      // Trim recommendations to exactly 5
      if (recommendations.length > 5) {
        recommendations.splice(5);
      }

      // Handle empty recommendations
      if (recommendations.length === 0) {
        recommendationsList.innerHTML = "<li>No valid recommendations found.</li>";
        return;
      }

      // Display recommendations
      recommendations.forEach(bookInfo => {
        const li = document.createElement("li");
        const link = document.createElement("a");
        link.href = bookInfo.link;
        link.target = "_blank";
        link.textContent = `${bookInfo.title} by ${bookInfo.authors.join(', ')}`;
        li.appendChild(link);
        recommendationsList.appendChild(li);
      });
    }
  </script>
</div>
</body>
</html>
