<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="static/styles.css">
  <title>Book Recommendation</title>
</head>
<body>
<div class="container">
  <h1>Book Recommendation System</h1>
  <div class="tabs">
    <button class="tab" data-tab="noXAI">No XAI</button>
    <button class="tab" data-tab="lime">LIME</button>
    <button class="tab" data-tab="shap">SHAP</button>
    <button class="tab" data-tab="counterfactual">Counterfactual</button>
  </div>
  <div id="tabContentContainer">
    <!-- Tab content for No XAI, LIME, SHAP, Counterfactual -->
    <div id="noXAI" class="tab-content" style="display:none;">
      <h2>No XAI Explanation</h2>
      <input type="text" id="bookTitleNoXAI" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorNoXAI" checked>
        <label for="includeSameAuthorNoXAI">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="noXAI">Get Recommendations</button>
      <ul id="recommendationsNoXAI"></ul>
    </div>
    <div id="lime" class="tab-content" style="display:none;">
      <h2>LIME Explanation</h2>
      <input type="text" id="bookTitleLime" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorLime" checked>
        <label for="includeSameAuthorLime">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="lime">Get Recommendations</button>
      <ul id="recommendationsLime"></ul>
      <div id="limeExplanation" style="display:none;">
        <h2>LIME Explanation for <span id="explainedTitleLime"></span></h2>
        <ul id="limeExplanationList"></ul>
      </div>
    </div>
    <div id="shap" class="tab-content" style="display:none;">
      <h2>SHAP Explanation</h2>
      <input type="text" id="bookTitleShap" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorShap" checked>
        <label for="includeSameAuthorShap">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="shap">Get Recommendations</button>
      <ul id="recommendationsShap"></ul>
      <div id="shapExplanation" style="display:none;">
        <h2>SHAP Explanation for <span id="explainedTitleShap"></span></h2>
        <ul id="shapExplanationList"></ul>
      </div>
    </div>
    <div id="counterfactual" class="tab-content" style="display:none;">
      <h2>Counterfactual Explanation</h2>
      <input type="text" id="bookTitleCounterfactual" placeholder="Enter a book title">
      <div class="toggle-label">
        <input type="checkbox" id="includeSameAuthorCounterfactual" checked>
        <label for="includeSameAuthorCounterfactual">Include recommendations by the same author</label>
      </div>
      <button class="get-recommendations-button" data-tab="counterfactual">Get Recommendations</button>
      <ul id="recommendationsCounterfactual"></ul>
      <div id="counterfactualExplanation" style="display:none;">
        <h2>Counterfactual Explanation for <span id="explainedTitleCounterfactual"></span></h2>
        <ul id="counterfactualExplanationList"></ul>
      </div>
    </div>
  </div>
</div>
<script>
  window.addEventListener("DOMContentLoaded", initTabs);
  document.querySelectorAll('.get-recommendations-button').forEach(button => {
    button.addEventListener('click', async () => {
      const tab = button.dataset.tab;
      await getRecommendations(tab);
    });
  });
  function initTabs() {
    const tabButtons = document.querySelectorAll(".tab");
    showTabContent("noXAI");
    document.querySelector('.tab[data-tab="noXAI"]').classList.add("active");
    tabButtons.forEach(button => button.addEventListener("click", () => handleTabClick(button.dataset.tab)));
  }

  function handleTabClick(tabId) {
    document.querySelectorAll(".tab").forEach(button => button.classList.remove("active"));
    document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add("active");
    showTabContent(tabId);
  }

  function showTabContent(tabId) {
    document.querySelectorAll(".tab-content").forEach(content => {
      content.style.display = content.id === tabId ? "block" : "none";
    });
  }

  async function getRecommendations(tab) {
    console.log(`Fetching recommendations for tab: ${tab}`);
    const inputId = `bookTitle${capitalize(tab)}`;
    const bookTitle = document.getElementById(inputId).value.toLowerCase();
    const recommendationsId = `recommendations${capitalize(tab)}`;
    const recommendationsList = document.getElementById(recommendationsId);
    recommendationsList.innerHTML = '';

    const includeSameAuthor = document.getElementById(`includeSameAuthor${capitalize(tab)}`).checked;
    const googleApiKey = 'AIzaSyDQTQy3LT7BOO_LLClbWuEvqiPbUbWWKBs'; // Replace with your actual API key
    const googleApiUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(bookTitle)}&maxResults=40&key=${googleApiKey}`;

    let books;
    try {
      const apiResponse = await fetch(googleApiUrl);
      const apiData = await apiResponse.json();
      books = apiData.items || [];
      console.log("Books fetched from Google API:", books);
    } catch (error) {
      console.error("Error fetching books from Google API", error);
      return;
    }

    const processedBooks = books.map(book => ({
      title: book.volumeInfo.title || "Unknown Title",
      authors: book.volumeInfo.authors || [],
      description: book.volumeInfo.description || "No description available",
      link: book.volumeInfo.infoLink || "#"
    }));

    const descriptions = processedBooks.map(book => book.description);
    const selectedBook = processedBooks.find(book => book.title.toLowerCase() === bookTitle.toLowerCase());

    if (!selectedBook) {
      console.error("Selected book not found in API response");
      return;
    }

    let tfidfData;
    let tfidfMatrix;
    let featureNames;
    try {
      const response = await fetch("/vectorize-descriptions", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({descriptions})
      });
      tfidfData = await response.json();
      tfidfMatrix = tfidfData.tfidf_matrix;
      featureNames = tfidfData.feature_names;
      console.log("TF-IDF vectorization data received from backend:", tfidfData);
    } catch (error) {
      console.error("Error during TF-IDF vectorization:", error);
      return;
    }

    const {tfidf_matrix, feature_names, description_vector} = tfidfData;
    const finalRecommendations = filterRecommendations(processedBooks, tfidf_matrix, description_vector, includeSameAuthor);
    console.log("Final filtered recommendations:", finalRecommendations);

    if (finalRecommendations.length === 0) {
      recommendationsList.innerHTML = "<li>No valid recommendations found.</li>";
      return;
    }

    finalRecommendations.forEach(bookInfo => {
      const li = document.createElement("li");
      const link = document.createElement("a");
      link.href = bookInfo.link;
      link.target = "_blank";
      link.textContent = `${bookInfo.title} by ${bookInfo.authors.join(', ')}`;
      li.appendChild(link);
      recommendationsList.appendChild(li);
    });

    if (!selectedBook) {
      console.error("Selected book not found in API response");
      return;
    }

    // Use selectedBook.description as bookDescription
    const bookDescription = selectedBook.description;

    // Create an array of descriptions for all books as allDescriptions
    const allDescriptions = processedBooks.map(book => book.description);

    // Assuming `finalRecommendations` contains the selected books
    const recommendedIndices = finalRecommendations.map(book => processedBooks.indexOf(book));

// Filter the TF-IDF matrix to only include rows for recommended books
    const filteredTfidfMatrix = recommendedIndices.map(index => tfidf_matrix[index]);

    try {
      let explanationData;
      if (tab === "lime") {
        explanationData = await fetchExplanation('lime', description_vector, feature_names);
      } else if (tab === "shap") {
        explanationData = await fetchExplanation('shap', description_vector, feature_names);
      } else if (tab === "counterfactual") {
        explanationData = await fetchExplanation('counterfactual', description_vector, feature_names);
      }

      // Display explanation for the active tab
      displayExplanation(explanationData, tab);
    } catch (error) {
      console.error(`Error fetching explanation for ${tab} tab:`, error);
    }
  }

    function capitalize(word) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }

  async function fetchExplanation(type, description_vector, featureNames) {
    const url = `/${type}-explanation`;

    // Limit data size for transmission
    const limitedDescriptionVector = description_vector.slice(0, 100); // Adjust as needed
    const limitedFeatureNames = featureNames.slice(0, 100);           // Adjust as needed

    // Log data length to troubleshoot
    console.log("Sending description vector length:", limitedDescriptionVector.length);
    console.log("Sending feature names length:", limitedFeatureNames.length);

    const response = await fetchExplanation(url, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
                             description_vector: limitedDescriptionVector,
                             feature_names: limitedFeatureNames
                           })
    });

    if (!response.ok) {
      console.error(`Error: ${response.status} - ${response.statusText}`);
      return { error: `Failed to fetch explanation for ${type}` };
    }

    return response.json();
  }



  function displayExplanation(data, type) {
      // Set up explanation title based on the type
      document.getElementById(`explainedTitle${capitalize(type)}`).textContent = data.title || "Unknown Title";

      const explanationListElement = document.getElementById(`${type}ExplanationList`);
      explanationListElement.innerHTML = ''; // Clear any previous explanation list items

      // Add a general explanation item, if available
      const generalExplanationItem = document.createElement('li');
      generalExplanationItem.textContent = data.general_explanation || "No general explanation provided.";
      explanationListElement.appendChild(generalExplanationItem);

      // Display explanation-specific details if available
      const explanationOutput = data[`${type}_output`];
      if (Array.isArray(explanationOutput)) {
        explanationOutput.forEach(item => {
          const listItem = document.createElement('li');
          listItem.textContent = `${item[0]}: ${item[1].toFixed(2)}`; // Displays word and its importance score
          explanationListElement.appendChild(listItem);
        });
      } else {
        // Handle missing explanation output
        const errorItem = document.createElement('li');
        errorItem.textContent = "Explanation output not available.";
        explanationListElement.appendChild(errorItem);
      }

      // Make the explanation container for the type visible
      document.getElementById(`${type}Explanation`).style.display = 'block';
    }


    function filterRecommendations(processedBooks, tfidf_matrix, description_vector, includeSameAuthor) {
      const finalRecommendations = [];
      const similarityScoreThreshold = 0.2;

      processedBooks.forEach((book, index) => {
        const bookVector = tfidf_matrix[index];
        const similarity = cosineSimilarity(description_vector, bookVector);

        if (similarity > similarityScoreThreshold) {
          const isSameAuthor = includeSameAuthor || !book.authors.some(author => processedBooks[0].authors.includes(author));
          if (isSameAuthor) {
            finalRecommendations.push(book);
          }
        }
      });

      return finalRecommendations.slice(0, 5); // Limit to top 5 recommendations
    }

    function cosineSimilarity(vecA, vecB) {
      const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
      const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
      const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
      return dotProduct / (magnitudeA * magnitudeB);
    }

</script>
</body>
</html>
